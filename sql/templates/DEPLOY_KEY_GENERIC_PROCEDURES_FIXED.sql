-- ============================================================================
-- KEY GENERIC PROCEDURES - TEMPLATED FROM WORKING STAGING VERSIONS
-- ============================================================================
-- Generated by extract_and_template_procedures.py
-- These are the working procedures from staging with database names templated
-- ============================================================================

-- ============================================================================
-- CALCULATE_VIEWERSHIP_METRICS
-- ============================================================================

CREATE OR REPLACE PROCEDURE {{UPLOAD_DB}}.public.calculate_viewership_metrics(PLATFORM VARCHAR, FILENAME VARCHAR)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS CALLER
AS
$$
try {
    const platform = PLATFORM;
    const filename = FILENAME;
    let updatedRecords = 0;
    // Calculate TOT_HOV from TOT_MOV (minutes to hours) when TOT_HOV is null
    const calculateHoursSQL = `
        UPDATE {{STAGING_DB}}.public.platform_viewership
        SET tot_hov = tot_mov / 60.0
        WHERE platform = ''''${platform}''''
          AND filename = ''''${filename}''''
          AND tot_mov IS NOT NULL
          AND tot_hov IS NULL
          AND processed IS NULL
    `;
    console.log("Calculating TOT_HOV from TOT_MOV...");
    const hoursStmt = snowflake.createStatement({sqlText: calculateHoursSQL});
    hoursStmt.execute();
    const hoursAffected = hoursStmt.getNumRowsAffected();
    updatedRecords += hoursAffected;
    console.log(`Calculated TOT_HOV for ${hoursAffected} records`);
    // Calculate TOT_MOV from TOT_HOV (hours to minutes) when TOT_MOV is null
    const calculateMinutesSQL = `
        UPDATE {{STAGING_DB}}.public.platform_viewership
        SET tot_mov = tot_hov * 60.0
        WHERE platform = ''''${platform}''''
          AND filename = ''''${filename}''''
          AND tot_hov IS NOT NULL
          AND tot_mov IS NULL
          AND processed IS NULL
    `;
    console.log("Calculating TOT_MOV from TOT_HOV...");
    const minutesStmt = snowflake.createStatement({sqlText: calculateMinutesSQL});
    minutesStmt.execute();
    const minutesAffected = minutesStmt.getNumRowsAffected();
    updatedRecords += minutesAffected;
    console.log(`Calculated TOT_MOV for ${minutesAffected} records`);
    // Log to error table
    snowflake.execute({
        sqlText: "INSERT INTO {{UPLOAD_DB}}.public.error_log_table (log_time, log_message, procedure_name, platform) VALUES (CURRENT_TIMESTAMP(), ?, ?, ?)",
        binds: [`Calculated missing viewership metrics. Total records updated: ${updatedRecords}`, ''''calculate_viewership_metrics'''', PLATFORM]
    });
    return `Successfully calculated missing metrics for ${updatedRecords} records`;
} catch (error) {
    const errorMessage = "Error in calculate_viewership_metrics: " + error.message;
    console.error(errorMessage);
    // Log error
    snowflake.execute({
        sqlText: "INSERT INTO {{UPLOAD_DB}}.public.error_log_table (log_time, log_message, procedure_name, platform, error_message) VALUES (CURRENT_TIMESTAMP(), ?, ?, ?, ?)",
        binds: [errorMessage, ''''calculate_viewership_metrics'''', PLATFORM, error.message]
    });
    return errorMessage;
}
$$;

GRANT USAGE ON PROCEDURE {{UPLOAD_DB}}.PUBLIC.CALCULATE_VIEWERSHIP_METRICS(STRING, STRING) TO ROLE web_app;

-- ============================================================================
-- SET_DATE_COLUMNS_DYNAMIC
-- ============================================================================

CREATE OR REPLACE PROCEDURE {{UPLOAD_DB}}.public.set_date_columns_dynamic(PLATFORM VARCHAR, FILENAME VARCHAR)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS CALLER
AS
$$
    // Function to execute a given SQL command and return a status message
    function executeSqlCommand(sql_command) {
        try {
            snowflake.execute({sqlText: sql_command});
            return "Succeeded";
        } catch (err) {
            return "Failed: " + err;
        }
    }
    const platform = PLATFORM;
    const filename = FILENAME;

    // First, check if there is a date column with data
    var checkDateQuery = `
        SELECT COUNT(*) as cnt
        FROM {{STAGING_DB}}.public.platform_viewership
        WHERE platform = ''''${platform}''''
          AND filename = ''''${filename}''''
          AND date IS NOT NULL
          AND TRIM(date) != ''''''''
    `;

    var dateCheckResult = snowflake.execute({sqlText: checkDateQuery});
    var hasDateColumn = false;
    if (dateCheckResult.next()) {
        hasDateColumn = dateCheckResult.getColumnValue(''''CNT'''') > 0;
    }

    var updateCommands = [];

    if (!hasDateColumn) {
        // No date column - check if we have month and year to construct year_month_day
        console.log(''''No date column found - checking for month/year columns'''');

        // Convert month name to numeric format
        updateCommands.push(`
            UPDATE {{STAGING_DB}}.public.platform_viewership
            SET month = CASE LOWER(month)
                WHEN ''''january'''' THEN ''''1''''
                WHEN ''''february'''' THEN ''''2''''
                WHEN ''''march'''' THEN ''''3''''
                WHEN ''''april'''' THEN ''''4''''
                WHEN ''''may'''' THEN ''''5''''
                WHEN ''''june'''' THEN ''''6''''
                WHEN ''''july'''' THEN ''''7''''
                WHEN ''''august'''' THEN ''''8''''
                WHEN ''''september'''' THEN ''''9''''
                WHEN ''''october'''' THEN ''''10''''
                WHEN ''''november'''' THEN ''''11''''
                WHEN ''''december'''' THEN ''''12''''
                ELSE month  -- If month is already numeric
            END
            WHERE platform = ''''${platform}''''
              AND filename = ''''${filename}''''
              AND processed IS NULL
              AND month IS NOT NULL
        `);

        // Set year_month_day from year + month (with day = 01)
        updateCommands.push(`
            UPDATE {{STAGING_DB}}.public.platform_viewership
            SET year_month_day = CONCAT(
                LPAD(CAST(year AS VARCHAR), 4, ''''0''''),
                LPAD(month, 2, ''''0''''),
                ''''01''''
            )
            WHERE platform = ''''${platform}''''
              AND filename = ''''${filename}''''
              AND processed IS NULL
              AND month IS NOT NULL
              AND year IS NOT NULL
              AND (year_month_day IS NULL OR year_month_day = '''''''')
        `);

        // Set week from year_month_day
        updateCommands.push(`
            UPDATE {{STAGING_DB}}.public.platform_viewership
            SET week = {{UPLOAD_DB}}.public.get_week_start(TO_DATE(year_month_day, ''''YYYYMMDD''''))
            WHERE platform = ''''${platform}''''
              AND filename = ''''${filename}''''
              AND processed IS NULL
              AND year_month_day IS NOT NULL
        `);

        // Set day from year_month_day
        updateCommands.push(`
            UPDATE {{STAGING_DB}}.public.platform_viewership
            SET day = {{UPLOAD_DB}}.public.get_day_from_mm_dd_yyyy(TO_DATE(year_month_day, ''''YYYYMMDD''''))
            WHERE platform = ''''${platform}''''
              AND filename = ''''${filename}''''
              AND processed IS NULL
              AND year_month_day IS NOT NULL
        `);

        // Set quarter based on month
        updateCommands.push(`
            UPDATE {{STAGING_DB}}.public.platform_viewership
            SET quarter = CASE
                WHEN CAST(month AS INT) IN (1, 2, 3) THEN ''''q1''''
                WHEN CAST(month AS INT) IN (4, 5, 6) THEN ''''q2''''
                WHEN CAST(month AS INT) IN (7, 8, 9) THEN ''''q3''''
                WHEN CAST(month AS INT) IN (10, 11, 12) THEN ''''q4''''
            END
            WHERE platform = ''''${platform}''''
              AND filename = ''''${filename}''''
              AND processed IS NULL
              AND month IS NOT NULL
        `);

        // Year should already be set from the upload, so skip that

    } else {
        // Has date column - use original logic
        console.log(''''Date column found - using standard date processing'''');

        // Update statement for getting the full date
        updateCommands.push(`UPDATE {{STAGING_DB}}.public.platform_viewership
         SET full_date = {{UPLOAD_DB}}.public.get_full_date(date)
         WHERE platform = ''''${platform}''''
           AND filename = ''''${filename}''''
           AND processed IS NULL`);

        // Update statement for setting the week start date
        updateCommands.push(`UPDATE {{STAGING_DB}}.public.platform_viewership
         SET week = {{UPLOAD_DB}}.public.get_week_start({{UPLOAD_DB}}.public.get_full_date(date))
         WHERE platform = ''''${platform}''''
           AND filename = ''''${filename}''''
           AND processed IS NULL`);

        // Update statement for setting the quarter
        updateCommands.push(`UPDATE {{STAGING_DB}}.public.platform_viewership
         SET quarter = {{UPLOAD_DB}}.public.get_quarter_from_mm_dd_yyyy({{UPLOAD_DB}}.public.get_full_date(date))
         WHERE platform = ''''${platform}''''
           AND filename = ''''${filename}''''
           AND processed IS NULL`);

        // Update statement for setting the year
        updateCommands.push(`UPDATE {{STAGING_DB}}.public.platform_viewership
         SET year = {{UPLOAD_DB}}.public.get_year_from_mm_dd_yyyy({{UPLOAD_DB}}.public.get_full_date(date))
         WHERE platform = ''''${platform}''''
           AND filename = ''''${filename}''''
           AND processed IS NULL`);

        // Update statement for setting the month
        updateCommands.push(`UPDATE {{STAGING_DB}}.public.platform_viewership
         SET month = {{UPLOAD_DB}}.public.get_month_from_mm_dd_yyyy({{UPLOAD_DB}}.public.get_full_date(date))
         WHERE platform = ''''${platform}''''
           AND filename = ''''${filename}''''
           AND processed IS NULL`);

        // Update statement for setting the first of the month
        updateCommands.push(`UPDATE {{STAGING_DB}}.public.platform_viewership
         SET year_month_day = {{UPLOAD_DB}}.public.get_first_of_month_from_mm_dd_yyyy({{UPLOAD_DB}}.public.get_full_date(date))
         WHERE platform = ''''${platform}''''
           AND filename = ''''${filename}''''
           AND processed IS NULL`);

        // Update statement for setting the day
        updateCommands.push(`UPDATE {{STAGING_DB}}.public.platform_viewership
         SET day = {{UPLOAD_DB}}.public.get_day_from_mm_dd_yyyy({{UPLOAD_DB}}.public.get_full_date(date))
         WHERE platform = ''''${platform}''''
           AND filename = ''''${filename}''''
           AND processed IS NULL`);
    }
    var resultMessage = "";
    for (var i = 0; i < updateCommands.length; i++) {
        resultMessage = executeSqlCommand(updateCommands[i]);
        if (resultMessage !== "Succeeded") {
            return "Error executing update command: " + resultMessage;
        }
    }
    return "All date columns set successfully for " + platform + " - " + filename;
$$;

GRANT USAGE ON PROCEDURE {{UPLOAD_DB}}.PUBLIC.SET_DATE_COLUMNS_DYNAMIC(STRING, STRING) TO ROLE web_app;

-- ============================================================================
-- SET_REF_ID_FROM_PLATFORM_CONTENT_ID
-- ============================================================================

CREATE OR REPLACE PROCEDURE {{UPLOAD_DB}}.public.set_ref_id_from_platform_content_id(PLATFORM VARCHAR, FILENAME VARCHAR)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS OWNER
AS
$$
try {
    const platformArg = PLATFORM;
    const filenameArg = FILENAME;
    console.log(`Setting ref_id from platform_content_id for ${platformArg} - ${filenameArg}`);
    // Step 1: Get all unique ref_ids from metadata
    // Using episode table as it has all the ref_ids we care about
    const getRefIdsSql = `
        SELECT DISTINCT ref_id
        FROM {{METADATA_DB}}.public.episode
        WHERE ref_id IS NOT NULL
          AND TRIM(ref_id) != ''''''''''''''''
    `;
    console.log(''''''''Fetching all known ref_ids from metadata...'''''''');
    const refIdsResult = snowflake.execute({sqlText: getRefIdsSql});
    // Store ref_ids in an array
    const refIds = [];
    while (refIdsResult.next()) {
        refIds.push(refIdsResult.getColumnValue(''''''''REF_ID''''''''));
    }
    console.log(`Found ${refIds.length} unique ref_ids in metadata`);
    if (refIds.length === 0) {
        return `No ref_ids found in metadata - skipping ref_id mapping`;
    }
    // Step 2: Update records where platform_content_id contains a known ref_id
    // We need to check if platform_content_id CONTAINS any of the known ref_ids
    // and extract the matching ref_id
    console.log(''''''''Updating ref_id column where platform_content_id contains known ref_ids...'''''''');
    let totalRowsUpdated = 0;
    // Process in batches to avoid SQL statement size limits
    const batchSize = 1000;
    for (let i = 0; i < refIds.length; i += batchSize) {
        const batch = refIds.slice(i, i + batchSize);
        // Create CASE statement to match and extract ref_ids
        const caseStatements = batch.map(refId => {
            const escapedRefId = refId.replace(/''''''''/g, "''''''''''''''''");
            return `WHEN CONTAINS(platform_content_id, ''''''''${escapedRefId}'''''''') THEN ''''''''${escapedRefId}''''''''`;
        }).join(''''''''\\\\\\\\n            '''''''');
        const updateSql = `
            UPDATE {{STAGING_DB}}.public.platform_viewership
            SET ref_id = CASE
                ${caseStatements}
            END
            WHERE UPPER(platform) = ''''''''${platformArg.toUpperCase()}''''''''
              AND LOWER(filename) = ''''''''${filenameArg.toLowerCase()}''''''''
              AND platform_content_id IS NOT NULL
              AND TRIM(platform_content_id) != ''''''''''''''''
              AND (ref_id IS NULL OR TRIM(ref_id) = '''''''''''''''')
              AND (${batch.map(refId => `CONTAINS(platform_content_id, ''''''''${refId.replace(/''''''''/g, "''''''''''''''''")}'''''''')`).join('''''''' OR '''''''')})
        `;
        const updateResult = snowflake.execute({sqlText: updateSql});
        const rowsUpdated = updateResult.getNumRowsAffected();
        totalRowsUpdated += rowsUpdated;
        console.log(`Processed batch ${Math.floor(i / batchSize) + 1}: ${rowsUpdated} rows updated`);
    }
    console.log(`âœ… Set ref_id for ${totalRowsUpdated} records from platform_content_id`);
    return `Successfully set ref_id for ${totalRowsUpdated} records matching known ref_ids`;
} catch (err) {
    const errorMessage = "Error in set_ref_id_from_platform_content_id: " + err.message;
    console.error(errorMessage);
    // Log the error
    try {
        snowflake.execute({
            sqlText: "INSERT INTO {{UPLOAD_DB}}.PUBLIC.ERROR_LOG_TABLE (LOG_MESSAGE, PROCEDURE_NAME, PLATFORM) VALUES (?, ?, ?)",
            binds: [errorMessage, ''''''''set_ref_id_from_platform_content_id'''''''', PLATFORM]
        });
    } catch (logErr) {
        console.error("Failed to log error: " + logErr.message);
    }
    throw new Error(errorMessage);
}
$$;

GRANT USAGE ON PROCEDURE {{UPLOAD_DB}}.PUBLIC.SET_REF_ID_FROM_PLATFORM_CONTENT_ID(STRING, STRING) TO ROLE web_app;

-- ============================================================================
-- SET_DEAL_PARENT_GENERIC
-- ============================================================================

CREATE OR REPLACE PROCEDURE {{UPLOAD_DB}}.public.set_deal_parent_generic(PLATFORM VARCHAR, FILENAME VARCHAR)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS CALLER
AS
$$
try {
    const platform = PLATFORM;
    const filename = FILENAME;
    // Update deal_parent AND all normalized fields by joining with active_deals table
    // For Owned and Operated: Match ONLY on platform + domain (ignore partner/channel/territory)
    // For Distribution Partners: Match on platform + domain + partner/channel/territory
    // Sets: deal_parent, partner, channel, territory, channel_id, territory_id
    const updateSql = `
        UPDATE {{STAGING_DB}}.public.platform_viewership v
        SET
            deal_parent = ad.deal_parent,
            partner = ad.internal_partner,
            channel = ad.internal_channel,
            territory = ad.internal_territory,
            channel_id = ad.internal_channel_id,
            territory_id = ad.internal_territory_id
        FROM dictionary.public.active_deals ad
        WHERE ad.platform = ''''${platform}''''
          AND UPPER(ad.domain) = UPPER(v.domain)
          AND ad.active = true
          AND (
              (
                  UPPER(v.domain) = ''''OWNED AND OPERATED''''
                  AND (v.platform_partner_name IS NULL OR UPPER(v.platform_partner_name) = UPPER(ad.platform_partner_name))
              )
              OR
              (
                  UPPER(v.domain) = ''''DISTRIBUTION PARTNERS''''
                  AND (v.platform_partner_name IS NULL OR UPPER(v.platform_partner_name) = UPPER(ad.platform_partner_name))
                  AND (v.platform_channel_name IS NULL OR UPPER(v.platform_channel_name) = UPPER(ad.platform_channel_name))
                  AND (v.platform_territory IS NULL OR UPPER(v.platform_territory) = UPPER(ad.platform_territory))
              )
          )
          AND v.filename = ''''${filename}''''
          AND v.platform = ''''${platform}''''
          AND v.deal_parent IS NULL
          AND v.processed IS NULL
    `;
    console.log("Setting deal_parent from active_deals...");
    const stmt = snowflake.createStatement({sqlText: updateSql});
    stmt.execute();
    const rowsAffected = stmt.getNumRowsAffected();
    console.log(`Updated deal_parent for ${rowsAffected} records`);
    // Log to error table
    snowflake.execute({
        sqlText: "INSERT INTO {{UPLOAD_DB}}.public.error_log_table (log_time, log_message, procedure_name, platform) VALUES (CURRENT_TIMESTAMP(), ?, ?, ?)",
        binds: [`Set deal_parent for ${rowsAffected} records`, ''''set_deal_parent_generic'''', PLATFORM]
    });
    // Check for records without deal_parent (no matching deals)
    const checkSql = `
        SELECT COUNT(*) as unmatched_count
        FROM {{STAGING_DB}}.public.platform_viewership
        WHERE platform = ''''${platform}''''
          AND filename = ''''${filename}''''
          AND deal_parent IS NULL
          AND processed IS NULL
    `;
    const checkStmt = snowflake.createStatement({sqlText: checkSql});
    const checkResult = checkStmt.execute();
    let unmatchedCount = 0;
    if (checkResult.next()) {
        unmatchedCount = checkResult.getColumnValue(1);
    }
    if (unmatchedCount > 0) {
        console.log(`Warning: ${unmatchedCount} records still have NULL deal_parent`);
        // Log warning
        snowflake.execute({
            sqlText: "INSERT INTO {{UPLOAD_DB}}.public.error_log_table (log_time, log_message, procedure_name, platform) VALUES (CURRENT_TIMESTAMP(), ?, ?, ?)",
            binds: [`WARNING: ${unmatchedCount} records have no matching active deals`, ''''set_deal_parent_generic'''', PLATFORM]
        });
    }
    return `Successfully set deal_parent for ${rowsAffected} records. ${unmatchedCount} records remain without deal_parent.`;
} catch (error) {
    const errorMessage = "Error in set_deal_parent_generic: " + error.message;
    console.error(errorMessage);
    // Log error
    snowflake.execute({
        sqlText: "INSERT INTO {{UPLOAD_DB}}.public.error_log_table (log_time, log_message, procedure_name, platform, error_message) VALUES (CURRENT_TIMESTAMP(), ?, ?, ?, ?)",
        binds: [errorMessage, ''''set_deal_parent_generic'''', PLATFORM, error.message]
    });
    return errorMessage;
}
$$;

GRANT USAGE ON PROCEDURE {{UPLOAD_DB}}.PUBLIC.SET_DEAL_PARENT_GENERIC(STRING, STRING) TO ROLE web_app;

-- ============================================================================
-- SET_PHASE_GENERIC
-- ============================================================================

CREATE OR REPLACE PROCEDURE {{UPLOAD_DB}}.public.set_phase_generic(PLATFORM VARCHAR, "PHASE_NUMBER" VARCHAR, FILENAME VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS
$$
BEGIN
    UPDATE {{STAGING_DB}}.public.platform_viewership
    SET phase = :phase_number
    WHERE UPPER(platform) = UPPER(:platform)
      AND filename = :filename
      AND (processed IS NULL OR processed = FALSE);
    RETURN ''Phase set to '' || :phase_number || '' for '' || SQLROWCOUNT || '' records'';
END;
$$;

GRANT USAGE ON PROCEDURE {{UPLOAD_DB}}.PUBLIC.SET_PHASE_GENERIC(STRING, STRING, STRING) TO ROLE web_app;

-- ============================================================================
-- ANALYZE_AND_PROCESS_VIEWERSHIP_DATA_GENERIC
-- ============================================================================

CREATE OR REPLACE PROCEDURE {{UPLOAD_DB}}.public.analyze_and_process_viewership_data_generic(PLATFORM VARCHAR, FILENAME VARCHAR)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS CALLER
AS
$$
const platformArg = PLATFORM;
const filenameArg = FILENAME;
// Use generic platform_viewership table
const viewershipTable = `{{STAGING_DB}}.public.platform_viewership`;
// Build base conditions with platform filter
// NOTE: We don''t require platform_content_name here because SERIES_SEASON_EPISODE bucket
// can match on series+episode+season without needing a title
const baseConditions = `platform = ''${platformArg}''
AND processed IS NULL
AND content_provider IS NULL
${filenameArg ? `AND filename = ''${filenameArg.replace(/''/g, "''''")}''` : ''''}`;
try {
    // Start time for procedure execution
    const startTime = new Date();
    // Function to log execution steps
    function logStep(message, status, rowsAffected = "0", errorMessage = "") {
        const executionTime = (new Date() - startTime) / 1000;
        const logSql = `
        INSERT INTO {{UPLOAD_DB}}.PUBLIC.ERROR_LOG_TABLE (
            LOG_TIME,
            LOG_MESSAGE,
            PROCEDURE_NAME,
            PLATFORM,
            STATUS,
            ROWS_AFFECTED,
            ERROR_MESSAGE,
            EXECUTION_TIME
        ) VALUES (
            CURRENT_TIMESTAMP(),
            ''${message.replace(/''/g, "''''")}'',
            ''analyze_and_process_viewership_data_generic'',
            ''${platformArg.replace(/''/g, "''''")}'',
            ''${status.replace(/''/g, "''''")}'',
            ''${rowsAffected.replace(/''/g, "''''")}'',
            ''${errorMessage.replace(/''/g, "''''")}'',
            ''${executionTime}''
        )`;
        try {
            snowflake.execute({sqlText: logSql});
        } catch (logErr) {
            // If logging fails, continue with procedure but note the error
        }
    }
    // Log procedure start
    logStep(`Starting procedure for platform: ${platformArg}, filename: ${filenameArg || ''ALL''}`, "STARTED");
    // Check if there are any records in the viewership table matching our criteria
    const recordCheckSql = `
        SELECT COUNT(*) AS RECORD_COUNT
        FROM ${viewershipTable}
        WHERE ${baseConditions}`;
    try {
        const recordCheckResult = snowflake.execute({sqlText: recordCheckSql});
        let recordCount = 0;
        if (recordCheckResult.next()) {
            recordCount = recordCheckResult.getColumnValue(''RECORD_COUNT'');
        }
        logStep(`Found ${recordCount} records to process in ${viewershipTable}`, "INFO");
        if (recordCount === 0) {
            const msg = `No records to process for platform ${platformArg}${filenameArg ? `, filename ${filenameArg}` : ''''}`;
            logStep(msg, "COMPLETED", "0");
            return msg;
        }
    } catch (err) {
        logStep(`Error checking for records: ${err.toString()}`, "ERROR");
        throw new Error(`Failed to access ${viewershipTable}: ${err.toString()}`);
    }
    // Define bucket categories based on what fields exist in viewership data
    const bucketCategories = [
        ["FULL_DATA", true, true, true, true],
        ["REF_ID_SERIES", true, true, null, null],
        ["REF_ID_ONLY", true, false, null, null],
        ["SERIES_SEASON_EPISODE", false, true, true, true],
        ["SERIES_ONLY", false, true, null, null],
        ["TITLE_ONLY", null, null, null, null]
    ];
    const bucketOrder = ["FULL_DATA", "REF_ID_SERIES", "REF_ID_ONLY", "SERIES_SEASON_EPISODE", "SERIES_ONLY", "TITLE_ONLY"];
    // Drop unmatched records table if it exists from previous runs
    try {
        snowflake.execute({
            sqlText: `DROP TABLE IF EXISTS {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED`
        });
        logStep("Dropped previous unmatched records table if it existed", "INFO");
    } catch (err) {
        logStep(`Warning: Error dropping unmatched records table: ${err.toString()}`, "WARNING");
    }
    // Delete old conflict records from previous runs of this same filename
    // This ensures Lambda gets accurate unmatched count for the current batch only
    if (filenameArg) {
        try {
            const deleteResult = snowflake.execute({
                sqlText: `DELETE FROM {{METADATA_DB}}.public.record_reprocessing_batch_logs WHERE filename = ''${filenameArg.replace(/''/g, "''''")}''`
            });
            const deletedCount = deleteResult.getNumRowsAffected();
            logStep(`Deleted ${deletedCount} old conflict records for filename: ${filenameArg}`, "INFO");
        } catch (err) {
            logStep(`Warning: Error deleting old conflict records: ${err.toString()}`, "WARNING");
        }
    }
    // Track successful buckets and their record counts
    const successfulBuckets = [];
    // Create temporary tables for each bucket
    logStep("Analyzing data distribution across bucket types", "IN_PROGRESS");
    for (const [bucketName, needsRefId, needsInternalSeries, needsEpisodeNum, needsSeasonNumber] of bucketCategories) {
        let conditions = [baseConditions];
        // Add specific conditions based on bucket type
        if (bucketName === "FULL_DATA") {
            conditions.push("ref_id IS NOT NULL AND TRIM(ref_id) != ''''");
            conditions.push("internal_series IS NOT NULL AND TRIM(internal_series) != ''''");
            conditions.push("episode_number IS NOT NULL AND TRIM(episode_number) != ''''");
            conditions.push("season_number IS NOT NULL AND TRIM(season_number) != ''''");
            conditions.push("REGEXP_LIKE(episode_number, ''^[0-9]+$'')");
            conditions.push("REGEXP_LIKE(season_number, ''^[0-9]+$'')");
        }
        else if (bucketName === "REF_ID_SERIES") {
            conditions.push("ref_id IS NOT NULL AND TRIM(ref_id) != ''''");
            conditions.push("internal_series IS NOT NULL AND TRIM(internal_series) != ''''");
        }
        else if (bucketName === "REF_ID_ONLY") {
            conditions.push("ref_id IS NOT NULL AND TRIM(ref_id) != ''''");
            conditions.push("(internal_series IS NULL OR TRIM(internal_series) = '''')");
        }
        else if (bucketName === "SERIES_SEASON_EPISODE") {
            conditions.push("internal_series IS NOT NULL AND TRIM(internal_series) != ''''");
            conditions.push("episode_number IS NOT NULL AND TRIM(episode_number) != ''''");
            conditions.push("season_number IS NOT NULL AND TRIM(season_number) != ''''");
            conditions.push("REGEXP_LIKE(episode_number, ''^[0-9]+$'')");
            conditions.push("REGEXP_LIKE(season_number, ''^[0-9]+$'')");
            conditions.push("(ref_id IS NULL OR TRIM(ref_id) = '''')");
        }
        else if (bucketName === "SERIES_ONLY") {
            conditions.push("internal_series IS NOT NULL AND TRIM(internal_series) != ''''");
            conditions.push("(ref_id IS NULL OR TRIM(ref_id) = '''')");
            conditions.push("((episode_number IS NULL OR TRIM(episode_number) = '''' OR NOT REGEXP_LIKE(episode_number, ''^[0-9]+$'')) OR (season_number IS NULL OR TRIM(season_number) = '''' OR NOT REGEXP_LIKE(season_number, ''^[0-9]+$'')))");
        }
        else if (bucketName === "TITLE_ONLY") {
            conditions.push("platform_content_name IS NOT NULL AND TRIM(platform_content_name) != ''''");
            conditions.push("(ref_id IS NULL OR TRIM(ref_id) = '''') AND (internal_series IS NULL OR TRIM(internal_series) = '''')");
        }
        // Check for any records matching this bucket before creating the temp table
        const checkSql = `
            SELECT COUNT(*) AS MATCH_COUNT
            FROM ${viewershipTable}
            WHERE ${conditions.join(" AND ")}`;
        let matchCount = 0;
        try {
            const checkResult = snowflake.execute({sqlText: checkSql});
            if (checkResult.next()) {
                matchCount = checkResult.getColumnValue(''MATCH_COUNT'');
            }
            logStep(`Found ${matchCount} records matching criteria for bucket ${bucketName}`, "INFO");
            if (matchCount === 0) {
                logStep(`Skipping bucket ${bucketName} - no matching records`, "INFO");
                continue;
            }
            // Add to successful buckets if it contains records
            successfulBuckets.push({
                name: bucketName,
                rowCount: matchCount
            });
        } catch (err) {
            logStep(`Error checking for matches in bucket ${bucketName}: ${err.toString()}`, "ERROR");
            continue;
        }
    }
    // If no successful buckets were created, return early
    if (successfulBuckets.length === 0) {
        logStep("No buckets with records were created, nothing to process", "COMPLETED", "0");
        return "No buckets with records were created, nothing to process";
    }
    // Now process each successful bucket with the appropriate matching strategy
    let totalProcessed = 0;
    const bucketResults = [];
    // First, manually create the unmatched records table with all records
    const createUnmatchedSql = `
    CREATE OR REPLACE TABLE {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED AS
    SELECT DISTINCT id
    FROM {{STAGING_DB}}.public.platform_viewership
    WHERE ${baseConditions}
    `;
    snowflake.execute({sqlText: createUnmatchedSql});
    // Check the initial count of records in the unmatched table
    const initialCountSql = `
    SELECT COUNT(*) AS INITIAL_COUNT
    FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED`;
    const initialCountResult = snowflake.execute({sqlText: initialCountSql});
    let initialCount = 0;
    if (initialCountResult.next()) {
        initialCount = initialCountResult.getColumnValue(''INITIAL_COUNT'');
    }
    logStep(`Initial count of records to process: ${initialCount}`, "INFO");
    // Process each bucket type in order
    for (const bucketType of bucketOrder) {
        // Check how many unmatched records we have left
        const checkUnmatchedSql = `
        SELECT COUNT(*) AS UNMATCHED_COUNT
        FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED`;
        const unmatchedResult = snowflake.execute({sqlText: checkUnmatchedSql});
        let unmatchedCount = 0;
        if (unmatchedResult.next()) {
            unmatchedCount = unmatchedResult.getColumnValue(''UNMATCHED_COUNT'');
        }
        logStep(`Processing ${bucketType} - Found ${unmatchedCount} unmatched records`, "INFO");
        if (unmatchedCount === 0) {
            logStep(`No unmatched records left to process for ${bucketType}`, "INFO");
            continue; // Skip to the next bucket type
        }
        // Create temporary bucket with unmatched records
        const bucketTableName = `TEMP_${platformArg.toUpperCase()}_${bucketType}_BUCKET`;
        // Create the bucket - with modified filtering to prevent full data records from flowing to less stringent procedures
        let createBucketSql;
        if (bucketType === "FULL_DATA") {
            createBucketSql = `
            CREATE OR REPLACE TEMPORARY TABLE {{UPLOAD_DB}}.PUBLIC.${bucketTableName} AS
            SELECT u.id
            FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u
            JOIN {{STAGING_DB}}.public.platform_viewership v ON u.id = v.id
            WHERE v.platform = ''${platformArg}''
            AND v.platform_content_name IS NOT NULL AND TRIM(v.platform_content_name) != ''''
            AND v.ref_id IS NOT NULL AND TRIM(v.ref_id) != ''''
            AND v.internal_series IS NOT NULL AND TRIM(v.internal_series) != ''''
            AND v.episode_number IS NOT NULL AND TRIM(v.episode_number) != ''''
            AND v.season_number IS NOT NULL AND TRIM(v.season_number) != ''''
            AND REGEXP_LIKE(v.episode_number, ''^[0-9]+$'')
            AND REGEXP_LIKE(v.season_number, ''^[0-9]+$'')
            `;
        } else if (bucketType === "REF_ID_SERIES") {
            createBucketSql = `
            CREATE OR REPLACE TEMPORARY TABLE {{UPLOAD_DB}}.PUBLIC.${bucketTableName} AS
            SELECT u.id
            FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u
            JOIN {{STAGING_DB}}.public.platform_viewership v ON u.id = v.id
            WHERE v.platform = ''${platformArg}''
            AND v.platform_content_name IS NOT NULL AND TRIM(v.platform_content_name) != ''''
            AND v.ref_id IS NOT NULL AND TRIM(v.ref_id) != ''''
            AND v.internal_series IS NOT NULL AND TRIM(v.internal_series) != ''''
            `;
        } else if (bucketType === "REF_ID_ONLY") {
            createBucketSql = `
            CREATE OR REPLACE TEMPORARY TABLE {{UPLOAD_DB}}.PUBLIC.${bucketTableName} AS
            SELECT u.id
            FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u
            JOIN {{STAGING_DB}}.public.platform_viewership v ON u.id = v.id
            WHERE v.platform = ''${platformArg}''
            AND v.platform_content_name IS NOT NULL AND TRIM(v.platform_content_name) != ''''
            AND v.ref_id IS NOT NULL AND TRIM(v.ref_id) != ''''
            AND (v.internal_series IS NULL OR TRIM(v.internal_series) = '''')
            `;
        } else if (bucketType === "SERIES_SEASON_EPISODE") {
            createBucketSql = `
            CREATE OR REPLACE TEMPORARY TABLE {{UPLOAD_DB}}.PUBLIC.${bucketTableName} AS
            SELECT u.id
            FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u
            JOIN {{STAGING_DB}}.public.platform_viewership v ON u.id = v.id
            WHERE v.platform = ''${platformArg}''
            AND v.internal_series IS NOT NULL AND TRIM(v.internal_series) != ''''
            AND v.episode_number IS NOT NULL AND TRIM(v.episode_number) != ''''
            AND v.season_number IS NOT NULL AND TRIM(v.season_number) != ''''
            AND REGEXP_LIKE(v.episode_number, ''^[0-9]+$'')
            AND REGEXP_LIKE(v.season_number, ''^[0-9]+$'')
            `;
        } else if (bucketType === "SERIES_ONLY") {
            createBucketSql = `
            CREATE OR REPLACE TEMPORARY TABLE {{UPLOAD_DB}}.PUBLIC.${bucketTableName} AS
            SELECT u.id
            FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u
            JOIN {{STAGING_DB}}.public.platform_viewership v ON u.id = v.id
            WHERE v.platform = ''${platformArg}''
            AND v.platform_content_name IS NOT NULL AND TRIM(v.platform_content_name) != ''''
            AND (v.ref_id IS NULL OR TRIM(v.ref_id) = '''')
            AND v.internal_series IS NOT NULL AND TRIM(v.internal_series) != ''''
            AND ((v.episode_number IS NULL OR TRIM(v.episode_number) = '''' OR NOT REGEXP_LIKE(v.episode_number, ''^[0-9]+$''))
                 OR (v.season_number IS NULL OR TRIM(v.season_number) = '''' OR NOT REGEXP_LIKE(v.season_number, ''^[0-9]+$'')))
            `;
        }
        else if (bucketType === "TITLE_ONLY") {
            createBucketSql = `
            CREATE OR REPLACE TEMPORARY TABLE {{UPLOAD_DB}}.PUBLIC.${bucketTableName} AS
            SELECT u.id
            FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u
            JOIN {{STAGING_DB}}.public.platform_viewership v ON u.id = v.id
            WHERE v.platform = ''${platformArg}''
            AND v.platform_content_name IS NOT NULL AND TRIM(v.platform_content_name) != ''''
            AND (v.ref_id IS NULL OR TRIM(v.ref_id) = '''')
            AND (v.internal_series IS NULL OR TRIM(v.internal_series) = '''')
            `;
        }
        snowflake.execute({sqlText: createBucketSql});
        // Count the actual records in the bucket
        const countActualSql = `SELECT COUNT(*) AS ACTUAL_COUNT FROM {{UPLOAD_DB}}.PUBLIC.${bucketTableName}`;
        const actualCountResult = snowflake.execute({sqlText: countActualSql});
        let actualCount = 0;
        if (actualCountResult.next()) {
            actualCount = actualCountResult.getColumnValue(''ACTUAL_COUNT'');
        }
        logStep(`${bucketType}: Starting to process ${actualCount} records`, "INFO");
        // If actual data count in bucket is zero, we don''t need to run bucket procs
        if (!actualCount) {
            logStep(`${bucketType}: Skipping - no records need processing`, "INFO");
            continue;
        }
        // Process this bucket with filename parameter - call the GENERIC sub-procedure
        const processSql = `
        CALL {{UPLOAD_DB}}.public.process_viewership_${bucketType.toLowerCase()}_generic(
            ''${platformArg}''
            ${filenameArg ? `, ''${filenameArg.replace(/''/g, "''''")}''` : '', NULL''}
        )`;
        try {
            const bucketResult = snowflake.execute({sqlText: processSql});
            let bucketResultStr = "";
            if (bucketResult.next()) {
                bucketResultStr = bucketResult.getColumnValue(1);
            }
            // Extract rows affected from the result
            const bucketRowsMatch = bucketResultStr.match(/updated (\\d+) rows/);
            const bucketRowsAffected = bucketRowsMatch ? bucketRowsMatch[1] : "0";
            const bucketRowsCount = parseInt(bucketRowsAffected, 10);
            logStep(`${bucketType}: Successfully updated ${bucketRowsAffected} records`, "SUCCESS", bucketRowsAffected);
            // IMPORTANT: Always count this bucket''s results, even if zero rows were affected
            bucketResults.push(`${bucketType}: ${bucketRowsAffected} records`);
            totalProcessed += bucketRowsCount;
            // Update the unmatched records table to remove any we just matched
            const updateUnmatchedSql = `
            DELETE FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u
            WHERE EXISTS (
                SELECT 1
                FROM {{STAGING_DB}}.public.platform_viewership v
                WHERE v.id = u.id
                AND v.platform = ''${platformArg}''
                AND v.content_provider IS NOT NULL
            )`;
            snowflake.execute({sqlText: updateUnmatchedSql});
            // Count how many records remain in the unmatched table
            const remainingUnmatchedSql = `
            SELECT COUNT(*) AS REMAINING_UNMATCHED
            FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED`;
            const remainingResult = snowflake.execute({sqlText: remainingUnmatchedSql});
            let remainingCount = 0;
            if (remainingResult.next()) {
                remainingCount = remainingResult.getColumnValue(''REMAINING_UNMATCHED'');
            }
            logStep(`After ${bucketType} processing, ${remainingCount} records still need processing by other strategies`, "INFO");
        } catch (err) {
            logStep(`Error processing ${bucketType} bucket: ${err.toString()}`, "ERROR");
        }
        // Clean up this bucket
        snowflake.execute({sqlText: `DROP TABLE IF EXISTS {{UPLOAD_DB}}.PUBLIC.${bucketTableName}`});
    }
    // Clean up all temporary bucket tables
    for (const bucketType of bucketOrder) {
        try {
            snowflake.execute({sqlText: `DROP TABLE IF EXISTS {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_${bucketType}_BUCKET`});
        } catch (err) {
            logStep(`Warning: Failed to drop temporary table for ${bucketType}`, "WARNING", "0", err.toString());
        }
    }
    // Calculate the total number of unmatched records
    const unmatchedCount = initialCount - totalProcessed;
    logStep(`Total records: ${initialCount}, Processed: ${totalProcessed}, Unmatched: ${unmatchedCount}`, "INFO");
    // Check for any records that remained unmatched
    try {
        const finalUnmatchedSql = `
        SELECT COUNT(*) AS FINAL_UNMATCHED
        FROM {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED`;
        const finalResult = snowflake.execute({sqlText: finalUnmatchedSql});
        let finalUnmatchedCount = 0;
        if (finalResult.next()) {
            finalUnmatchedCount = finalResult.getColumnValue(''FINAL_UNMATCHED'');
        }
        if (finalUnmatchedCount > 0) {
            logStep(`FINAL RESULT: ${finalUnmatchedCount} records could not be processed by any strategy`, "WARNING");
            // Log these final unmatched records to record_reprocessing_batch_logs
            // This ensures Lambda verification accounts for ALL records
            const logFinalUnmatchedSql = `
                INSERT INTO {{METADATA_DB}}.public.record_reprocessing_batch_logs (
                    title,
                    viewership_id,
                    filename,
                    notes,
                    platform
                )
                SELECT
                    v.platform_content_name,
                    v.id,
                    v.filename,
                    ''Final unmatched: No bucket could process this record'',
                    ''${platformArg}''
                FROM {{STAGING_DB}}.public.platform_viewership v
                JOIN {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED u ON v.id = u.id
                WHERE v.platform = ''${platformArg}''
                  ${filenameArg ? `AND v.filename = ''${filenameArg.replace(/''/g, "''''")}''` : ''''}
                  AND v.content_provider IS NULL
                  AND v.processed IS NULL
                  AND NOT EXISTS (
                      SELECT 1
                      FROM {{METADATA_DB}}.public.record_reprocessing_batch_logs l
                      WHERE l.viewership_id = v.id
                  )
            `;
            const logResult = snowflake.execute({sqlText: logFinalUnmatchedSql});
            const rowsLogged = logResult.getNumRowsAffected();
            logStep(`Logged ${rowsLogged} final unmatched records to record_reprocessing_batch_logs`, "INFO");
        }
        // Clean up the unmatched records table
        snowflake.execute({sqlText: `DROP TABLE IF EXISTS {{UPLOAD_DB}}.PUBLIC.TEMP_${platformArg.toUpperCase()}_UNMATCHED`});
        logStep("Dropped unmatched records table", "INFO");
    } catch (err) {
        logStep(`Warning: Failed to finalize unmatched records: ${err.toString()}`, "WARNING", "0", err.toString());
    }
    const totalExecutionTime = (new Date() - startTime) / 1000;
    const completionMessage = filenameArg
        ? `Processing completed for platform ${platformArg}, filename ${filenameArg} in ${totalExecutionTime} seconds. Total records processed: ${totalProcessed}`
        : `Processing completed for platform ${platformArg} in ${totalExecutionTime} seconds. Total records processed: ${totalProcessed}`;
    logStep(completionMessage, "COMPLETED", totalProcessed.toString());
    // IMPORTANT: Always return a success message if totalProcessed > 0
    if (totalProcessed > 0) {
        return `FINAL SUMMARY: Successfully updated ${totalProcessed} total records. Breakdown: ${bucketResults.join(", ")}`;
    } else {
        return `FINAL SUMMARY: No records were updated by any strategy.`;
    }
}
catch (err) {
    return `Error in analyze_and_process_viewership_data_generic: ${err.message}`;
}
$$;

GRANT USAGE ON PROCEDURE {{UPLOAD_DB}}.PUBLIC.ANALYZE_AND_PROCESS_VIEWERSHIP_DATA_GENERIC(STRING, STRING) TO ROLE web_app;

-- ============================================================================
-- HANDLE_FINAL_INSERT_DYNAMIC_GENERIC
-- ============================================================================

CREATE OR REPLACE PROCEDURE {{UPLOAD_DB}}.public.handle_final_insert_dynamic_generic(PLATFORM VARCHAR, TYPE VARCHAR, FILENAME VARCHAR DEFAULT null)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS CALLER
AS
$$
    function executeStoredProcedure(procName, args) {
        try {
            var sqlCommand = `CALL ` + procName + (args.length > 0 ? `(${args.map(arg => arg === null ? ''NULL'' : `''${String(arg).replace(/''/g, "''''")}''`).join('','')})` : ''()'') + `;`;
            var result = snowflake.createStatement({sqlText: sqlCommand}).execute();
            if (result.next()) {
                return { success: true, message: procName + " executed successfully.", data: result.getColumnValue(1) };
            }
            return { success: true, message: procName + " executed successfully." };
        } catch (err) {
            // Logging the error to the console
            console.error("Error executing " + procName + ": " + err.message);
            // Returning error details for further handling
            return { success: false, message: "Error executing " + procName + ": " + err.message };
        }
    }
    function sendValidationErrorEmail(platform, filename, validationData) {
        try {
            // Format date for email
            var today = new Date();
            var dateStr = today.toISOString().split("T")[0];
            // Build HTML email content
            var html_message = ''<html><body style="font-family: Arial, sans-serif;">'';
            html_message += ''<h2 style="color: #FF0000;">ðŸš¨ URGENT! Validation Errors in Viewership Data</h2>'';
            html_message += ''<p><strong>Platform:</strong> '' + platform + ''</p>'';
            if (filename) {
                html_message += ''<p><strong>Filename:</strong> '' + filename + ''</p>'';
            }
            html_message += ''<p><strong>Date:</strong> '' + dateStr + ''</p>'';
            html_message += ''<p><strong>Total Records Checked:</strong> '' + validationData.validationCount + ''</p>'';
            html_message += ''<p><strong>Total Errors Found:</strong> '' + validationData.errors.length + ''</p>'';
            // Show error summary
            html_message += "<h3>Error Summary</h3>";
            // Group errors by type
            var errorTypes = {};
            validationData.errors.forEach(function(err) {
                if (!errorTypes[err.error]) {
                    errorTypes[err.error] = 0;
                }
                errorTypes[err.error]++;
            });
            html_message += "<ul>";
            for (var errorType in errorTypes) {
                html_message += ''<li>'' + errorType + '': '' + errorTypes[errorType] + '' records</li>'';
            }
            html_message += "</ul>";
            // Show detailed errors (limit to first 50 for email size)
            var errorLimit = Math.min(50, validationData.errors.length);
            html_message += ''<h3>Detailed Errors (showing first '' + errorLimit + '' of '' + validationData.errors.length + '')</h3>'';
            html_message += ''<table style="border-collapse: collapse; width: 100%;">'';
            html_message += ''<thead>'';
            html_message += ''<tr style="background-color: #f2f2f2;">'';
            html_message += ''<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Record ID</th>'';
            html_message += ''<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Error Type</th>'';
            html_message += ''<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Details</th>'';
            html_message += ''</tr>'';
            html_message += ''</thead>'';
            html_message += ''<tbody>'';
            // Add rows for each error (up to limit)
            for (var i = 0; i < errorLimit; i++) {
                var err = validationData.errors[i];
                html_message += ''<tr>'';
                html_message += ''<td style="border: 1px solid #ddd; padding: 8px;">'' + err.id + ''</td>'';
                html_message += ''<td style="border: 1px solid #ddd; padding: 8px;">'' + err.error + ''</td>'';
                // Build details column based on error fields
                var details = "";
                for (var key in err) {
                    if (key !== ''id'' && key !== ''error'') {
                        details += ''<strong>'' + key + '':</strong> '' + err[key] + ''<br>'';
                    }
                }
                html_message += ''<td style="border: 1px solid #ddd; padding: 8px;">'' + details + ''</td>'';
                html_message += ''</tr>'';
            }
            html_message += ''</tbody></table>'';
            html_message += ''<p><strong>Action Required:</strong> Please fix these validation errors before attempting to insert the data again.</p>'';
            html_message += ''</body></html>'';
            // Send email using the monitoring procedure
            snowflake.execute({
                sqlText: `
                CALL SYSTEM$SEND_EMAIL(
                    ''SNOWFLAKE_EMAIL_SENDER'',
                    ''tayloryoung@mvmediasales.com, data@nosey.com'',
                    ?,
                    ?,
                    ''text/html''
                )`,
                binds: [
                    "ðŸš¨ URGENT: Viewership Validation Errors - " + platform + (filename ? '' - '' + filename : ''''),
                    html_message
                ]
            });
            return { success: true, message: "Validation error email sent." };
        } catch (err) {
            console.error("Error sending validation error email: " + err.message);
            return { success: false, message: "Error sending validation error email: " + err.message };
        }
    }
    // First, run the validation procedure (if it exists)
    // Note: validate_viewership_for_insert may need to be created or updated for generic architecture
    try {
        var validationResult = executeStoredProcedure("{{UPLOAD_DB}}.public.validate_viewership_for_insert", [PLATFORM, FILENAME, TYPE]);
        if (validationResult.success && validationResult.data) {
            // Check validation results
            var validationData = validationResult.data;
            if (!validationData.valid) {
                // Send email notification about validation errors
                var emailResult = sendValidationErrorEmail(PLATFORM, FILENAME, validationData);
                // Log the validation failure and return - THIS TERMINATES THE PROCESS
                var errorCount = validationData.errors.length;
                var recordCount = validationData.validationCount;
                var errorMessage = `Validation failed: ${errorCount} errors found in ${recordCount} records. Email notification sent.`;
                console.error(errorMessage);
                // Return detailed error message
                return errorMessage;
            }
            // Log validation results with matched/unmatched breakdown
            var matched = validationData.matchedCount || validationData.validationCount;
            var unmatched = validationData.unmatchedCount || 0;
            console.log(`Validation passed: ${validationData.validationCount} total records, ${matched} matched, ${unmatched} unmatched (expected).`);
        }
    } catch (validationErr) {
        // If validation procedure doesn''t exist or fails, log and continue
        console.log("Validation step skipped or failed: " + validationErr.message);
    }
    // If validation passes or is skipped, proceed with the regular procedure sequence
    var procedures = [
        { name: `{{UPLOAD_DB}}.public.move_data_to_final_table_dynamic_generic`, args: [PLATFORM, TYPE, FILENAME] },
        { name: "{{UPLOAD_DB}}.public.set_phase_generic", args: [PLATFORM, 3, FILENAME] },
    ];
    for (var i = 0; i < procedures.length; i++) {
        var proc = procedures[i];
        var result = executeStoredProcedure(proc.name, proc.args);
        if (!result.success) {
            // If a procedure fails, log the failure and halt further execution
            console.error(result.message);
            return result.message;
        }
    }
    console.log("All procedures executed successfully.");
    return "All procedures executed successfully.";
$$;

GRANT USAGE ON PROCEDURE {{UPLOAD_DB}}.PUBLIC.HANDLE_FINAL_INSERT_DYNAMIC_GENERIC(STRING, STRING, STRING) TO ROLE web_app;

